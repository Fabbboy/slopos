#![allow(dead_code)]

use core::ffi::{c_char, c_int};
use core::ptr;

use crate::framebuffer;
use crate::graphics;

const FONT_CHAR_WIDTH: i32 = 8;
const FONT_CHAR_HEIGHT: i32 = 16;
const FONT_FIRST_CHAR: u8 = 32;
const FONT_LAST_CHAR: u8 = 126;
const FONT_CHAR_COUNT: usize = (FONT_LAST_CHAR - FONT_FIRST_CHAR + 1) as usize;

const FONT_SUCCESS: c_int = 0;
const FONT_ERROR_NO_FB: c_int = -1;
const FONT_ERROR_BOUNDS: c_int = -2;
const FONT_ERROR_INVALID: c_int = -3;

// Simple console state mirroring the legacy C implementation.
struct ConsoleState {
    cursor_x: i32,
    cursor_y: i32,
    fg_color: u32,
    bg_color: u32,
    initialized: bool,
}

impl ConsoleState {
    pub const fn new() -> Self {
        Self {
            cursor_x: 0,
            cursor_y: 0,
            fg_color: 0xFFFF_FFFF,
            bg_color: 0x0000_0000,
            initialized: false,
        }
    }
}

static FONT_CONSOLE: spin::Mutex<ConsoleState> = spin::Mutex::new(const { ConsoleState::new() });

// Glyph data copied 1:1 from the original 8x16 bitmap font.
#[allow(clippy::unreadable_literal)]
static FONT_DATA: [[u8; FONT_CHAR_HEIGHT as usize]; FONT_CHAR_COUNT] = [
    // Space (32)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    // ! (33)
    [0x00, 0x00, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00],
    // " (34)
    [0x00, 0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    // # (35)
    [0x00, 0x00, 0x00, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00],
    // $ (36)
    [0x00, 0x00, 0x18, 0x18, 0x7C, 0xC6, 0xC2, 0xC0, 0x7C, 0x06, 0x06, 0x86, 0xC6, 0x7C, 0x18, 0x18],
    // % (37)
    [0x00, 0x00, 0x00, 0x00, 0xC2, 0xC6, 0x0C, 0x18, 0x30, 0x60, 0xC6, 0x86, 0x00, 0x00, 0x00, 0x00],
    // & (38)
    [0x00, 0x00, 0x38, 0x6C, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00],
    // ' (39)
    [0x00, 0x00, 0x30, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    // ( (40)
    [0x00, 0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00],
    // ) (41)
    [0x00, 0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00],
    // * (42)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    // + (43)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    // , (44)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00],
    // - (45)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    // . (46)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00],
    // / (47)
    [0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00],
    // 0 (48)
    [0x00, 0x00, 0x3C, 0x66, 0xC3, 0xC3, 0xDB, 0xDB, 0xC3, 0xC3, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00],
    // 1 (49)
    [0x00, 0x00, 0x18, 0x38, 0x58, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00],
    // 2 (50)
    [0x00, 0x00, 0x7C, 0xC6, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00],
    // 3 (51)
    [0x00, 0x00, 0x7C, 0xC6, 0x06, 0x06, 0x3C, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00],
    // 4 (52)
    [0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00, 0x00],
    // 5 (53)
    [0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xFC, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00],
    // 6 (54)
    [0x00, 0x00, 0x38, 0x60, 0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00],
    // 7 (55)
    [0x00, 0x00, 0xFE, 0xC6, 0x06, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00],
    // 8 (56)
    [0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00],
    // 9 (57)
    [0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x06, 0x06, 0x0C, 0x78, 0x00, 0x00, 0x00, 0x00],
    // : (58)
    [0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00],
    // ; (59)
    [0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00],
    // < (60)
    [0x00, 0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00],
    // = (61)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    // > (62)
    [0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00],
    // ? (63)
    [0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x0C, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00],
    // @ (64)
    [0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xDE, 0xDE, 0xDE, 0xDC, 0xC0, 0xC0, 0x7C, 0x00, 0x00, 0x00, 0x00],
    // A (65)
    [0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00],
    // B (66)
    [0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00, 0x00],
    // C (67)
    [0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0, 0xC0, 0xC2, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00],
    // D (68)
    [0x00, 0x00, 0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, 0x00, 0x00, 0x00],
    // E (69)
    [0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00],
    // F (70)
    [0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00],
    // G (71)
    [0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xDE, 0xC6, 0xC6, 0x66, 0x3A, 0x00, 0x00, 0x00, 0x00],
    // H (72)
    [0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00],
    // I (73)
    [0x00, 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00],
    // J (74)
    [0x00, 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00],
    // K (75)
    [0x00, 0x00, 0xE6, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00],
    // L (76)
    [0x00, 0x00, 0xF0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00],
    // M (77)
    [0x00, 0x00, 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00],
    // N (78)
    [0x00, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00],
    // O (79)
    [0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00],
    // P (80)
    [0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00],
    // Q (81)
    [0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x0C, 0x0E, 0x00, 0x00],
    // R (82)
    [0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00],
    // S (83)
    [0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x60, 0x38, 0x0C, 0x06, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00],
    // T (84)
    [0x00, 0x00, 0x7E, 0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00],
    // U (85)
    [0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00],
    // V (86)
    [0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00],
    // W (87)
    [0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xD6, 0xD6, 0xFE, 0xEE, 0x6C, 0x00, 0x00, 0x00, 0x00],
    // X (88)
    [0x00, 0x00, 0xC6, 0xC6, 0x6C, 0x7C, 0x38, 0x38, 0x7C, 0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00],
    // Y (89)
    [0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00],
    // Z (90)
    [0x00, 0x00, 0xFE, 0xC6, 0x86, 0x0C, 0x18, 0x30, 0x60, 0xC2, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00],
    // [ (91)
    [0x00, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x00],
    // \ (92)
    [0x00, 0x00, 0x00, 0x80, 0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00],
    // ] (93)
    [0x00, 0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00, 0x00],
    // ^ (94)
    [0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    // _ (95)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00],
    // ` (96)
    [0x00, 0x00, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    // a (97)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00],
    // b (98)
    [0x00, 0x00, 0xE0, 0x60, 0x60, 0x78, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x00],
    // c (99)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00],
    // d (100)
    [0x00, 0x00, 0x1C, 0x0C, 0x0C, 0x3C, 0x6C, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00],
    // e (101)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00],
    // f (102)
    [0x00, 0x00, 0x1C, 0x36, 0x32, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00, 0x00, 0x00, 0x00],
    // g (103)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xCC, 0x78, 0x00, 0x00],
    // h (104)
    [0x00, 0x00, 0xE0, 0x60, 0x60, 0x6C, 0x76, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00],
    // i (105)
    [0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00],
    // j (106)
    [0x00, 0x00, 0x06, 0x06, 0x00, 0x0E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00, 0x00],
    // k (107)
    [0x00, 0x00, 0xE0, 0x60, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00],
    // l (108)
    [0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00],
    // m (109)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xD6, 0xD6, 0xD6, 0xC6, 0x00, 0x00, 0x00, 0x00],
    // n (110)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00],
    // o (111)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00],
    // p (112)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00, 0x00],
    // q (113)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0x0C, 0x1E, 0x00, 0x00],
    // r (114)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00],
    // s (115)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0x60, 0x38, 0x0C, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00],
    // t (116)
    [0x00, 0x00, 0x10, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00],
    // u (117)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00],
    // v (118)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00],
    // w (119)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xD6, 0xD6, 0xFE, 0x6C, 0x00, 0x00, 0x00, 0x00],
    // x (120)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x6C, 0x38, 0x38, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00],
    // y (121)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0xF8, 0x00, 0x00],
    // z (122)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xCC, 0x18, 0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00],
    // { (123)
    [0x00, 0x00, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x18, 0x18, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00, 0x00],
    // | (124)
    [0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00],
    // } (125)
    [0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00],
    // ~ (126)
    [0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
];

fn framebuffer_ready() -> bool {
    framebuffer::framebuffer_is_initialized() != 0
}

fn framebuffer_dims() -> (i32, i32) {
    (
        framebuffer::framebuffer_get_width() as i32,
        framebuffer::framebuffer_get_height() as i32,
    )
}

fn glyph_for_char(c: c_char) -> &'static [u8; FONT_CHAR_HEIGHT as usize] {
    let ch = (c as i8) as u8;
    let glyph = if ch < FONT_FIRST_CHAR || ch > FONT_LAST_CHAR {
        b' '
    } else {
        ch
    };
    &FONT_DATA[(glyph - FONT_FIRST_CHAR) as usize]
}

#[no_mangle]
pub extern "C" fn font_draw_char(x: i32, y: i32, c: c_char, fg_color: u32, bg_color: u32) -> c_int {
    if !framebuffer_ready() {
        return FONT_ERROR_NO_FB;
    }

    let (fb_w, fb_h) = framebuffer_dims();
    let glyph = glyph_for_char(c);

    for (row_idx, byte) in glyph.iter().copied().enumerate() {
        let py = y + row_idx as i32;
        if py < 0 || py >= fb_h {
            continue;
        }
        for col in 0..FONT_CHAR_WIDTH {
            let px = x + col;
            if px < 0 || px >= fb_w {
                continue;
            }
            if byte & (0x80 >> col) != 0 {
                graphics::graphics_draw_pixel(px, py, fg_color);
            } else if bg_color != 0 {
                graphics::graphics_draw_pixel(px, py, bg_color);
            }
        }
    }

    FONT_SUCCESS
}

unsafe fn c_str_len(ptr: *const c_char) -> usize {
    if ptr.is_null() {
        return 0;
    }
    let mut len = 0usize;
    let mut p = ptr;
    unsafe {
        while *p != 0 {
            len += 1;
            p = p.add(1);
        }
    }
    len
}

unsafe fn c_str_to_bytes<'a>(ptr: *const c_char, buf: &'a mut [u8]) -> &'a [u8] {
    if ptr.is_null() {
        return &[];
    }
    let len = unsafe { c_str_len(ptr) }.min(buf.len());
    for i in 0..len {
        unsafe {
            buf[i] = *ptr.add(i) as u8;
        }
    }
    &buf[..len]
}

#[no_mangle]
pub extern "C" fn font_draw_string(x: i32, y: i32, str_ptr: *const c_char, fg_color: u32, bg_color: u32) -> c_int {
    if !framebuffer_ready() {
        return FONT_ERROR_NO_FB;
    }
    if str_ptr.is_null() {
        return FONT_ERROR_INVALID;
    }

    let (fb_w, fb_h) = framebuffer_dims();
    let mut cx = x;
    let mut cy = y;
    let mut tmp = [0u8; 1024];
    let text = unsafe { c_str_to_bytes(str_ptr, &mut tmp) };

    for &ch in text {
        let c = ch as c_char;
        match ch {
            b'\n' => {
                cx = x;
                cy += FONT_CHAR_HEIGHT;
            }
            b'\r' => {
                cx = x;
            }
            b'\t' => {
                let tab_width = 4 * FONT_CHAR_WIDTH;
                cx = ((cx - x + tab_width) / tab_width) * tab_width + x;
            }
            _ => {
                font_draw_char(cx, cy, c, fg_color, bg_color);
                cx += FONT_CHAR_WIDTH;
                if cx + FONT_CHAR_WIDTH > fb_w {
                    cx = x;
                    cy += FONT_CHAR_HEIGHT;
                }
            }
        }

        if cy >= fb_h {
            break;
        }
    }

    FONT_SUCCESS
}

#[no_mangle]
pub extern "C" fn font_draw_string_clear(
    x: i32,
    y: i32,
    str_ptr: *const c_char,
    fg_color: u32,
    bg_color: u32,
) -> c_int {
    if str_ptr.is_null() {
        return FONT_ERROR_INVALID;
    }

    let width = font_get_string_width(str_ptr);
    let height = FONT_CHAR_HEIGHT;
    graphics::graphics_draw_rect_filled(x, y, width, height, bg_color);
    font_draw_string(x, y, str_ptr, fg_color, bg_color)
}

#[no_mangle]
pub extern "C" fn font_get_string_width(str_ptr: *const c_char) -> i32 {
    if str_ptr.is_null() {
        return 0;
    }
    let mut width = 0;
    let mut p = str_ptr;
    loop {
        let ch = unsafe { *p };
        if ch == 0 || ch == b'\n' as c_char {
            break;
        }
        if ch == b'\t' as c_char {
            let tab_width = 4 * FONT_CHAR_WIDTH;
            width = ((width + tab_width - 1) / tab_width) * tab_width;
        } else {
            width += FONT_CHAR_WIDTH;
        }
        unsafe {
            p = p.add(1);
        }
    }
    width
}

#[no_mangle]
pub extern "C" fn font_get_string_lines(str_ptr: *const c_char) -> c_int {
    if str_ptr.is_null() {
        return 0;
    }
    let mut lines = 1;
    let mut p = str_ptr;
    loop {
        let ch = unsafe { *p };
        if ch == 0 {
            break;
        }
        if ch == b'\n' as c_char {
            lines += 1;
        }
        unsafe {
            p = p.add(1);
        }
    }
    lines
}

fn console_scroll_up(state: &mut ConsoleState) {
    let fb = match framebuffer::snapshot() {
        Some(fb) => fb,
        None => return,
    };

    let bpp_bytes = ((fb.bpp as usize) + 7) / 8;
    if bpp_bytes == 0 || fb.pitch == 0 {
        return;
    }

    if fb.height <= FONT_CHAR_HEIGHT as u32 {
        graphics::graphics_draw_rect_filled(0, 0, fb.width as i32, fb.height as i32, state.bg_color);
        state.cursor_y = 0;
        return;
    }

    let src_offset = FONT_CHAR_HEIGHT as usize * fb.pitch as usize;
    let copy_bytes = (fb.height as usize - FONT_CHAR_HEIGHT as usize) * fb.pitch as usize;

    unsafe {
        ptr::copy(
            fb.base.add(src_offset),
            fb.base,
            copy_bytes,
        );
    }

    graphics::graphics_draw_rect_filled(
        0,
        fb.height as i32 - FONT_CHAR_HEIGHT,
        fb.width as i32,
        FONT_CHAR_HEIGHT,
        state.bg_color,
    );
    state.cursor_y = fb.height as i32 - FONT_CHAR_HEIGHT;
}

#[no_mangle]
pub extern "C" fn font_console_init(fg_color: u32, bg_color: u32) {
    let mut console = FONT_CONSOLE.lock();
    console.cursor_x = 0;
    console.cursor_y = 0;
    console.fg_color = fg_color;
    console.bg_color = bg_color;
    console.initialized = true;
}

#[no_mangle]
pub extern "C" fn font_console_putc(c: c_char) -> c_int {
    if !framebuffer_ready() {
        return FONT_ERROR_NO_FB;
    }

    let mut console = FONT_CONSOLE.lock();
    if !console.initialized {
        return FONT_ERROR_NO_FB;
    }

    match c as u8 {
        b'\n' => {
            console.cursor_x = 0;
            console.cursor_y += FONT_CHAR_HEIGHT;
        }
        b'\r' => {
            console.cursor_x = 0;
        }
        _ => {
            font_draw_char(console.cursor_x, console.cursor_y, c, console.fg_color, console.bg_color);
            console.cursor_x += FONT_CHAR_WIDTH;
            if console.cursor_x + FONT_CHAR_WIDTH > framebuffer::framebuffer_get_width() as i32 {
                console.cursor_x = 0;
                console.cursor_y += FONT_CHAR_HEIGHT;
            }
        }
    }

    if console.cursor_y + FONT_CHAR_HEIGHT > framebuffer::framebuffer_get_height() as i32 {
        console_scroll_up(&mut console);
    }

    FONT_SUCCESS
}

#[no_mangle]
pub extern "C" fn font_console_puts(str_ptr: *const c_char) -> c_int {
    if str_ptr.is_null() {
        return FONT_ERROR_INVALID;
    }
    let mut p = str_ptr;
    loop {
        let ch = unsafe { *p };
        if ch == 0 {
            break;
        }
        font_console_putc(ch);
        unsafe {
            p = p.add(1);
        }
    }
    FONT_SUCCESS
}

#[no_mangle]
pub extern "C" fn font_console_clear() -> c_int {
    if !framebuffer_ready() {
        return FONT_ERROR_NO_FB;
    }
    {
        let mut console = FONT_CONSOLE.lock();
        graphics::graphics_draw_rect_filled(
            0,
            0,
            framebuffer::framebuffer_get_width() as i32,
            framebuffer::framebuffer_get_height() as i32,
            console.bg_color,
        );
        console.cursor_x = 0;
        console.cursor_y = 0;
    }
    FONT_SUCCESS
}

#[no_mangle]
pub extern "C" fn font_console_set_colors(fg_color: u32, bg_color: u32) {
    let mut console = FONT_CONSOLE.lock();
    console.fg_color = fg_color;
    console.bg_color = bg_color;
}


